#!/usr/bin/env python3
# Repeated RSA – solve script
from math import gcd
from itertools import permutations

# ---- données du challenge ----
c = int("9281773316120350315826907806520559817444561211011988641015426039152919084313218839788802529759220156095222918014358588164712744457411489810471078979440693678635385889978824998147332489867324980077335149522660658521632946341248435046700549521064854814673927080235501844478078087125767372666366815199837763622919751713551452390128441218320917092494084056137627971480558273760918327050821616864342634116437633410520821134031440942633128130715646803414949025642899694129734517860274023352351147963702729509066577244118849930240762575192232563647273846782261554851439475411926563766997474754827102480557961332006144467949")

n1 = int("23898347839679019753207646056017080293879211470205178923889828570162481379214424373649998146625033979179656646915817859560615061728792615879218440906887696162655708425091422239687745013098783576889644450082667950217524538426828246887996724177062947313114577545864728733116671809003148638751570491231727365329961528660066949388248822425184533132042734368415062834268999504350008447543134986684331292790270945844920177984083837030590537969159843513922898073564209138629568187146851182263556726543866667583201894548381157491437602899003505847944661992338842857278762398754045946158210196588066504632865482637026991690101")

n2 = int("20044952544808348159705370809137965702421547800663883028387908238839457395057958876241581360883666703359414639106136785829317409899233703723190055956896527360148854898293227873614951684123513655744467194039523467571288040967643552458272511314006009435302688669070210462643460511440642599346419109840438545057712907426269010003651886534027795618350120059934303221806971250570361432103684864460713664577762134829789740792098403350636927620175770779236313995667521089641401290612617683680014232655053378662292997803188088512968141227380945523561961162272614488915858986214746911645973396182561710073516866395852282636329")

n3 = int("15176669401114750927413725946969784175008183607673756225130370253164859119845977602194725493432057855404905332815035309931268382611653117542998925645157102253562854766511471021650636933696394640995654051071310115173869063018649689235421719873374151678883756502272586079633781583256618047799661791779244833132974292930806271239609417369145070048104610433220401015623346691576376806643065972352660939070910341332112892127926573347021288353309654951846665255252325705608949842745911414560562361917893986740807103012585487643285905298535023330792556335284426611692641970632821848104580034140724325858677044980501674179981")

e = 65537

# ---- helpers ----
def i2b(x: int) -> bytes:
    return x.to_bytes((x.bit_length() + 7) // 8, "big")

def modinv(a: int, m: int) -> int:
    # Python 3.8+: pow supports modular inverse; fallback just in case
    try:
        return pow(a, -1, m)
    except TypeError:
        # Extended Euclid
        def egcd(a, b):
            if b == 0:
                return (a, 1, 0)
            g, y, x = egcd(b, a % b)
            return (g, x, y - (a // b) * x)
        g, x, _ = egcd(a, m)
        if g != 1:
            raise ValueError("inverse does not exist")
        return x % m

# ---- factorisations via GCD (les modules partagent des facteurs) ----
p12 = gcd(n1, n2)  # = pA
p13 = gcd(n1, n3)  # = pB
p23 = gcd(n2, n3)  # = pC

assert n1 == p12 * p13
assert n2 == p12 * p23
assert n3 == p13 * p23

phi1 = (p12 - 1) * (p13 - 1)
phi2 = (p12 - 1) * (p23 - 1)
phi3 = (p13 - 1) * (p23 - 1)

d1 = modinv(e, phi1)
d2 = modinv(e, phi2)
d3 = modinv(e, phi3)

keys = {
    'n1': (n1, d1),
    'n2': (n2, d2),
    'n3': (n3, d3),
}

# On ne connaît pas l’ordre d’encryptage, donc on teste les 6 permutations
flag = None
for enc_order in permutations(['n1', 'n2', 'n3'], 3):
    # déchiffrer dans l’ordre inverse
    x = c
    for name in reversed(enc_order):
        n, d = keys[name]
        x = pow(x, d, n)
    pt = i2b(x)
    if b'ctf{' in pt or b'CTF{' in pt:
        flag = pt.decode(errors='ignore')
        print("[+] Encryption order was:", " -> ".join(enc_order))
        print("[+] Flag:", flag)
        break

if not flag:
    # Rien trouvé ? Afficher les 3 décodages simples (au cas où).
    print("[-] Aucun flag trouvé automatiquement. Candidats (simple RSA) :")
    for name, (n, d) in keys.items():
        m = pow(c, d, n)
        print(name, i2b(m))
